/*
 * dmUploader - jQuery Ajax File Uploader Widget
 * https://github.com/danielm/uploader
 *
 * Copyright Daniel Morales <daniel85mg@gmail.com>
 * Released under the MIT license.
 * https://github.com/danielm/uploader/blob/master/LICENSE.txt
 *
 * @preserve
 */
// !function(e){"use strict";"function"==typeof define&&define.amd?define(["jquery"],e):"undefined"!=typeof exports?module.exports=e(require("jquery")):e(window.jQuery)}(function(e){"use strict";var t="dmUploader",n=0,i=1,s=2,o=3,r=4,u={auto:!0,queue:!0,dnd:!0,hookDocument:!0,multiple:!0,url:document.URL,method:"POST",extraData:{},headers:{},dataType:null,fieldName:"file",maxFileSize:0,allowedTypes:"*",extFilter:null,onInit:function(){},onComplete:function(){},onFallbackMode:function(){},onNewFile:function(){},onBeforeUpload:function(){},onUploadProgress:function(){},onUploadSuccess:function(){},onUploadCanceled:function(){},onUploadError:function(){},onUploadComplete:function(){},onFileTypeError:function(){},onFileSizeError:function(){},onFileExtError:function(){},onDragEnter:function(){},onDragLeave:function(){},onDocumentDragEnter:function(){},onDocumentDragLeave:function(){}},a=function(e,t){this.data=e,this.widget=t,this.jqXHR=null,this.status=n,this.id=Math.random().toString(36).substr(2)};a.prototype.upload=function(){var t=this;if(!t.canUpload())return t.widget.queueRunning&&t.status!==i&&t.widget.processQueue(),!1;var n=new FormData;n.append(t.widget.settings.fieldName,t.data);var s=t.widget.settings.extraData;return"function"==typeof s&&(s=s.call(t.widget.element,t.id)),e.each(s,function(e,t){n.append(e,t)}),t.status=i,t.widget.activeFiles++,t.widget.settings.onBeforeUpload.call(t.widget.element,t.id),t.jqXHR=e.ajax({url:t.widget.settings.url,type:t.widget.settings.method,dataType:t.widget.settings.dataType,data:n,headers:t.widget.settings.headers,cache:!1,contentType:!1,processData:!1,forceSync:!1,xhr:function(){return t.getXhr()},success:function(e){t.onSuccess(e)},error:function(e,n,i){t.onError(e,n,i)},complete:function(){t.onComplete()}}),!0},a.prototype.onSuccess=function(e){this.status=s,this.widget.settings.onUploadSuccess.call(this.widget.element,this.id,e)},a.prototype.onError=function(e,t,n){this.status!==r&&(this.status=o,this.widget.settings.onUploadError.call(this.widget.element,this.id,e,t,n))},a.prototype.onComplete=function(){this.widget.activeFiles--,this.status!==r&&this.widget.settings.onUploadComplete.call(this.widget.element,this.id),this.widget.queueRunning?this.widget.processQueue():this.widget.settings.queue&&0===this.widget.activeFiles&&this.widget.settings.onComplete.call(this.element)},a.prototype.getXhr=function(){var t=this,n=e.ajaxSettings.xhr();return n.upload&&n.upload.addEventListener("progress",function(e){var n=0,i=e.loaded||e.position,s=e.total||e.totalSize;e.lengthComputable&&(n=Math.ceil(i/s*100)),t.widget.settings.onUploadProgress.call(t.widget.element,t.id,n)},!1),n},a.prototype.cancel=function(e){e=void 0!==e&&e;var t=this.status;return!!(t===i||e&&t===n)&&(this.status=r,this.widget.settings.onUploadCanceled.call(this.widget.element,this.id),t===i&&this.jqXHR.abort(),!0)},a.prototype.canUpload=function(){return this.status===n||this.status===o};var l=function(t,n){return this.element=e(t),this.settings=e.extend({},u,n),this.checkSupport()?(this.init(),this):(e.error("Browser not supported by jQuery.dmUploader"),this.settings.onFallbackMode.call(this.element),!1)};l.prototype.checkSupport=function(){if(void 0===window.FormData)return!1;return!new RegExp("/(Android (1.0|1.1|1.5|1.6|2.0|2.1))|(Windows Phone (OS 7|8.0))|(XBLWP)|(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|(Kindle/(1.0|2.0|2.5|3.0))/").test(window.navigator.userAgent)&&!e('<input type="file" />').prop("disabled")},l.prototype.init=function(){var n=this;this.queue=[],this.queuePos=-1,this.queueRunning=!1,this.activeFiles=0,this.draggingOver=0,this.draggingOverDoc=0;var i=n.element.is("input[type=file]")?n.element:n.element.find("input[type=file]");return i.length>0&&(i.prop("multiple",this.settings.multiple),i.on("change."+t,function(t){var i=t.target&&t.target.files;i&&i.length&&(n.addFiles(i),e(this).val(""))})),this.settings.dnd&&this.initDnD(),0!==i.length||this.settings.dnd?(this.settings.onInit.call(this.element),this):(e.error("Markup error found by jQuery.dmUploader"),null)},l.prototype.initDnD=function(){var n=this;n.element.on("drop."+t,function(e){e.preventDefault(),n.draggingOver>0&&(n.draggingOver=0,n.settings.onDragLeave.call(n.element));var t=e.originalEvent&&e.originalEvent.dataTransfer;if(t&&t.files&&t.files.length){var i=[];n.settings.multiple?i=t.files:i.push(t.files[0]),n.addFiles(i)}}),n.element.on("dragenter."+t,function(e){e.preventDefault(),0===n.draggingOver&&n.settings.onDragEnter.call(n.element),n.draggingOver++}),n.element.on("dragleave."+t,function(e){e.preventDefault(),n.draggingOver--,0===n.draggingOver&&n.settings.onDragLeave.call(n.element)}),n.settings.hookDocument&&(e(document).off("drop."+t).on("drop."+t,function(e){e.preventDefault(),n.draggingOverDoc>0&&(n.draggingOverDoc=0,n.settings.onDocumentDragLeave.call(n.element))}),e(document).off("dragenter."+t).on("dragenter."+t,function(e){e.preventDefault(),0===n.draggingOverDoc&&n.settings.onDocumentDragEnter.call(n.element),n.draggingOverDoc++}),e(document).off("dragleave."+t).on("dragleave."+t,function(e){e.preventDefault(),n.draggingOverDoc--,0===n.draggingOverDoc&&n.settings.onDocumentDragLeave.call(n.element)}),e(document).off("dragover."+t).on("dragover."+t,function(e){e.preventDefault()}))},l.prototype.releaseEvents=function(){this.element.off("."+t),this.element.find("input[type=file]").off("."+t),this.settings.hookDocument&&e(document).off("."+t)},l.prototype.validateFile=function(t){if(this.settings.maxFileSize>0&&t.size>this.settings.maxFileSize)return this.settings.onFileSizeError.call(this.element,t),!1;if("*"!==this.settings.allowedTypes&&!t.type.match(this.settings.allowedTypes))return this.settings.onFileTypeError.call(this.element,t),!1;if(null!==this.settings.extFilter){var n=t.name.toLowerCase().split(".").pop();if(e.inArray(n,this.settings.extFilter)<0)return this.settings.onFileExtError.call(this.element,t),!1}return new a(t,this)},l.prototype.addFiles=function(e){for(var t=0,n=0;n<e.length;n++){var i=this.validateFile(e[n]);if(i){!1!==this.settings.onNewFile.call(this.element,i.id,i.data)&&(this.settings.auto&&!this.settings.queue&&i.upload(),this.queue.push(i),t++)}}return 0===t?this:(this.settings.auto&&this.settings.queue&&!this.queueRunning&&this.processQueue(),this)},l.prototype.processQueue=function(){return this.queuePos++,this.queuePos>=this.queue.length?(0===this.activeFiles&&this.settings.onComplete.call(this.element),this.queuePos=this.queue.length-1,this.queueRunning=!1,!1):(this.queueRunning=!0,this.queue[this.queuePos].upload())},l.prototype.restartQueue=function(){this.queuePos=-1,this.queueRunning=!1,this.processQueue()},l.prototype.findById=function(e){for(var t=!1,n=0;n<this.queue.length;n++)if(this.queue[n].id===e){t=this.queue[n];break}return t},l.prototype.cancelAll=function(){var e=this.queueRunning;this.queueRunning=!1;for(var t=0;t<this.queue.length;t++)this.queue[t].cancel();e&&this.settings.onComplete.call(this.element)},l.prototype.startAll=function(){if(this.settings.queue)this.restartQueue();else for(var e=0;e<this.queue.length;e++)this.queue[e].upload()},l.prototype.methods={start:function(t){if(this.queueRunning)return!1;var i=!1;return void 0===t||(i=this.findById(t))?i?(i.status===r&&(i.status=n),i.upload()):(this.startAll(),!0):(e.error("File not found in jQuery.dmUploader"),!1)},cancel:function(t){var n=!1;return void 0===t||(n=this.findById(t))?n?n.cancel(!0):(this.cancelAll(),!0):(e.error("File not found in jQuery.dmUploader"),!1)},reset:function(){return this.cancelAll(),this.queue=[],this.queuePos=-1,this.activeFiles=0,!0},destroy:function(){this.cancelAll(),this.releaseEvents(),this.element.removeData(t)}},e.fn.dmUploader=function(n){var i=arguments;if("string"!=typeof n)return this.each(function(){e.data(this,t)||e.data(this,t,new l(this,n))});this.each(function(){var s=e.data(this,t);s instanceof l?"function"==typeof s.methods[n]?s.methods[n].apply(s,Array.prototype.slice.call(i,1)):e.error("Method "+n+" does not exist in jQuery.dmUploader"):e.error("Unknown plugin data found by jQuery.dmUploader")})}});

/*
 * dmUploader - jQuery Ajax File Uploader Widget
 * https://github.com/danielm/uploader
 *
 * Copyright Daniel Morales <daniel85mg@gmail.com>
 * Released under the MIT license.
 * https://github.com/danielm/uploader/blob/master/LICENSE.txt
 *
 * @preserve
 */

/* global define, define, window, document, FormData */


// Это функция получения $_GET параметра по ключу из URL
function $_GET(key) {
    var p = window.location.search;
    p = p.match(new RegExp(key + '=([^&=]+)'));
    return p ? p[1] : false;
}

(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define(["jquery"], factory);
    } else if (typeof exports !== "undefined") {
        module.exports = factory(require("jquery"));
    } else {
        // Browser globals
        factory(window.jQuery);
    }
}(function($) {
    "use strict";

    var pluginName = "dmUploader";

    var FileStatus = {
        PENDING: 0,
        UPLOADING: 1,
        COMPLETED: 2,
        FAILED: 3,
        CANCELLED: 4 //(by the user)
    };

    // These are the plugin defaults values
    var defaults = {
        auto: true,
        queue: true,
        dnd: true,
        hookDocument: true,
        multiple: true,
        url: document.URL,
        method: "POST",
        extraData: {},
        headers: {},
        dataType: null,
        fieldName: "file",
        maxFileSize: 0,
        allowedTypes: "*",
        extFilter: null,
        onInit: function(){},
        onComplete: function(){},
        onFallbackMode: function() {},
        onNewFile: function(){},        //params: id, file
        onBeforeUpload: function(){},   //params: id
        onUploadProgress: function(){}, //params: id, percent
        onUploadSuccess: function(){},  //params: id, data
        onUploadCanceled: function(){}, //params: id
        onUploadError: function(){},    //params: id, xhr, status, message
        onUploadComplete: function(){}, //params: id
        onFileTypeError: function(){},  //params: file
        onFileSizeError: function(){},  //params: file
        onFileExtError: function(){},   //params: file
        onDragEnter: function(){},
        onDragLeave: function(){},
        onDocumentDragEnter: function(){},
        onDocumentDragLeave: function(){}
    };

    var DmUploaderFile = function(file, widget)
    {
        this.data = file;

        this.widget = widget;

        this.jqXHR = null;

        this.status = FileStatus.PENDING;

        // The file id doesnt have to bo that special.... or not?
        this.id = Math.random().toString(36).substr(2);
    };




    DmUploaderFile.prototype.upload = function()
    {
        var file = this;

        if (!file.canUpload()) {

            if (file.widget.queueRunning && file.status !== FileStatus.UPLOADING) {
                file.widget.processQueue();
            }

            return false;
        }

        // Form Data
        var fd = new FormData();
        fd.append(file.widget.settings.fieldName, file.data);
        fd.append( 'report_id',$_GET('report_id'));



        // Append extra Form Data
        var customData = file.widget.settings.extraData;
        if (typeof(customData) === "function") {
            customData = customData.call(file.widget.element, file.id);
        }

        $.each(customData, function(exKey, exVal) {
            fd.append(exKey, exVal);
        });

        file.status = FileStatus.UPLOADING;
        file.widget.activeFiles++;

        file.widget.settings.onBeforeUpload.call(file.widget.element, file.id);

        // Ajax Submit
        file.jqXHR = $.ajax({
            url: file.widget.settings.url,
            type: file.widget.settings.method,
            dataType: file.widget.settings.dataType,
            data: fd,
            headers: file.widget.settings.headers,
            cache: false,
            contentType: false,
            processData: false,
            forceSync: false,
            xhr: function() { return file.getXhr(); },
            success: function(data) { file.onSuccess(data); },
            error: function(xhr, status, errMsg) { file.onError(xhr, status, errMsg); },
            complete: function() { file.onComplete(); },
        });

        return true;
    };

    DmUploaderFile.prototype.onSuccess = function(data)
    {
        this.status = FileStatus.COMPLETED;
        this.widget.settings.onUploadSuccess.call(this.widget.element, this.id, data);
    };

    DmUploaderFile.prototype.onError = function(xhr, status, errMsg)
    {
        // If the status is: cancelled (by the user) don't invoke the error callback
        if (this.status !== FileStatus.CANCELLED) {
            this.status = FileStatus.FAILED;
            this.widget.settings.onUploadError.call(this.widget.element, this.id, xhr, status, errMsg);
        }
    };

    DmUploaderFile.prototype.onComplete = function()
    {
        this.widget.activeFiles--;

        if (this.status !== FileStatus.CANCELLED) {
            this.widget.settings.onUploadComplete.call(this.widget.element, this.id);
        }

        if (this.widget.queueRunning) {
            this.widget.processQueue();
        } else if (this.widget.settings.queue && this.widget.activeFiles === 0) {
            this.widget.settings.onComplete.call(this.element);
        }
    };

    DmUploaderFile.prototype.getXhr = function()
    {
        var file = this;
        var xhrobj = $.ajaxSettings.xhr();

        if (xhrobj.upload) {
            xhrobj.upload.addEventListener("progress", function(event) {
                var percent = 0;
                var position = event.loaded || event.position;
                var total = event.total || event.totalSize;

                if (event.lengthComputable) {
                    percent = Math.ceil(position / total * 100);
                }
                file.widget.settings.onUploadProgress.call(file.widget.element, file.id, percent);
            }, false);
        }

        return xhrobj;
    };

    DmUploaderFile.prototype.cancel = function(abort)
    {
        // The abort flag is to track if we are calling this function directly (using the cancel Method, by id)
        // or the call comes from the 'gobal' method aka cancelAll.
        // THis mean that we don't want to trigger the cancel event on file that isn't uploading, UNLESS directly doing it
        // ... and yes, it could be done prettier. Review (?)
        abort = (typeof abort === "undefined" ? false : abort);

        var myStatus = this.status;

        if (myStatus === FileStatus.UPLOADING || (abort && myStatus === FileStatus.PENDING)) {
            this.status = FileStatus.CANCELLED;
        } else {
            return false;
        }

        this.widget.settings.onUploadCanceled.call(this.widget.element, this.id);

        if (myStatus === FileStatus.UPLOADING) {
            this.jqXHR.abort();
        }

        return true;
    };

    DmUploaderFile.prototype.canUpload = function()
    {
        return (
            this.status === FileStatus.PENDING ||
            this.status === FileStatus.FAILED
        );
    };

    var DmUploader = function(element, options)
    {
        this.element = $(element);
        this.settings = $.extend({}, defaults, options);

        if (!this.checkSupport()) {
            $.error("Browser not supported by jQuery.dmUploader");

            this.settings.onFallbackMode.call(this.element);

            return false;
        }

        this.init();

        return this;
    };

    DmUploader.prototype.checkSupport = function()
    {
        // This one is mandatory for all modes
        if (typeof window.FormData === "undefined") {
            return false;
        }

        // Test based on: Modernizr/feature-detects/forms/fileinput.js
        var exp = new RegExp(
            "/(Android (1.0|1.1|1.5|1.6|2.0|2.1))|"+
            "(Windows Phone (OS 7|8.0))|(XBLWP)|"+
            "(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|"+
            "(Kindle\/(1.0|2.0|2.5|3.0))/");

        if (exp.test(window.navigator.userAgent)) {
            return false;
        }

        return !$("<input type=\"file\" />").prop("disabled");
    };

    DmUploader.prototype.init = function()
    {
        var widget = this;

        // Queue vars
        this.queue = [];
        this.queuePos = -1;
        this.queueRunning = false;
        this.activeFiles = 0;
        this.draggingOver = 0;
        this.draggingOverDoc = 0;

        var input = widget.element.is("input[type=file]") ?
            widget.element : widget.element.find("input[type=file]");

        //-- Is the input our main element itself??
        if (input.length > 0) {
            input.prop("multiple", this.settings.multiple);

            // Or does it has the input as a child
            input.on("change." + pluginName, function(evt) {
                var files = evt.target && evt.target.files;

                if (!files || !files.length){
                    return;
                }

                widget.addFiles(files);

                $(this).val("");
            });
        }

        if (this.settings.dnd) {
            this.initDnD();
        }

        if (input.length === 0 && !this.settings.dnd) {
            // Trigger an error because if this happens the plugin wont do anything.
            $.error("Markup error found by jQuery.dmUploader");

            return null;
        }

        // We good to go, tell them!
        this.settings.onInit.call(this.element);

        return this;
    };

    DmUploader.prototype.initDnD = function()
    {
        var widget = this;

        // -- Now our own Drop
        widget.element.on("drop." + pluginName, function (evt) {
            evt.preventDefault();

            if (widget.draggingOver > 0){
                widget.draggingOver = 0;
                widget.settings.onDragLeave.call(widget.element);
            }

            var dataTransfer = evt.originalEvent && evt.originalEvent.dataTransfer;
            if (!dataTransfer || !dataTransfer.files || !dataTransfer.files.length) {
                return;
            }

            // Take only the first file if not acepting multiple, this is kinda ugly. Needs Review ?
            var files = [];

            if (widget.settings.multiple) {
                files = dataTransfer.files;
            } else {
                files.push(dataTransfer.files[0]);
            }

            widget.addFiles(files);
        });

        //-- These two events/callbacks are onlt to maybe do some fancy visual stuff
        widget.element.on("dragenter." + pluginName, function(evt) {
            evt.preventDefault();

            if (widget.draggingOver === 0){
                widget.settings.onDragEnter.call(widget.element);
            }

            widget.draggingOver++;
        });

        widget.element.on("dragleave." + pluginName, function(evt) {
            evt.preventDefault();

            widget.draggingOver--;

            if (widget.draggingOver === 0){
                widget.settings.onDragLeave.call(widget.element);
            }
        });

        if (!widget.settings.hookDocument) {
            return;
        }

        // Adding some off/namepacing to prevent some weird cases when people use multiple instances
        $(document).off("drop." + pluginName).on("drop." + pluginName, function(evt) {
            evt.preventDefault();

            if (widget.draggingOverDoc > 0){
                widget.draggingOverDoc = 0;
                widget.settings.onDocumentDragLeave.call(widget.element);
            }
        });

        $(document).off("dragenter." + pluginName).on("dragenter." + pluginName, function(evt) {
            evt.preventDefault();

            if (widget.draggingOverDoc === 0){
                widget.settings.onDocumentDragEnter.call(widget.element);
            }

            widget.draggingOverDoc++;
        });

        $(document).off("dragleave." + pluginName).on("dragleave." + pluginName, function(evt) {
            evt.preventDefault();

            widget.draggingOverDoc--;

            if (widget.draggingOverDoc === 0){
                widget.settings.onDocumentDragLeave.call(widget.element);
            }
        });

        $(document).off("dragover." + pluginName).on("dragover." + pluginName, function(evt) {
            evt.preventDefault();
        });
    };

    DmUploader.prototype.releaseEvents = function() {
        // Leave everyone ALONE ;_;

        this.element.off("." + pluginName);
        this.element.find("input[type=file]").off("." + pluginName);

        if (this.settings.hookDocument) {
            $(document).off("." + pluginName);
        }
    };

    DmUploader.prototype.validateFile = function(file)
    {
        // Check file size
        if ((this.settings.maxFileSize > 0) &&
            (file.size > this.settings.maxFileSize)) {

            this.settings.onFileSizeError.call(this.element, file);

            return false;
        }

        // Check file type
        if ((this.settings.allowedTypes !== "*") &&
            !file.type.match(this.settings.allowedTypes)){

            this.settings.onFileTypeError.call(this.element, file);

            return false;
        }

        // Check file extension
        if (this.settings.extFilter !== null) {
            var ext = file.name.toLowerCase().split(".").pop();

            if ($.inArray(ext, this.settings.extFilter) < 0) {
                this.settings.onFileExtError.call(this.element, file);

                return false;
            }
        }

        return new DmUploaderFile(file, this);
    };

    DmUploader.prototype.addFiles = function(files)
    {
        var nFiles = 0;

        for (var i= 0; i < files.length; i++)
        {
            var file = this.validateFile(files[i]);

            if (!file){
                continue;
            }

            // If the callback returns false file will not be processed. This may allow some customization
            var can_continue = this.settings.onNewFile.call(this.element, file.id, file.data);
            if (can_continue === false) {
                continue;
            }

            // If we are using automatic uploading, and not a file queue: go for the upload
            if (this.settings.auto && !this.settings.queue) {
                file.upload();
            }

            this.queue.push(file);

            nFiles++;
        }

        // No files were added
        if (nFiles === 0) {
            return this;
        }

        // Are we auto-uploading files?
        if (this.settings.auto && this.settings.queue && !this.queueRunning) {
            this.processQueue();
        }

        return this;
    };

    DmUploader.prototype.processQueue = function()
    {
        this.queuePos++;

        if (this.queuePos >= this.queue.length) {
            if (this.activeFiles === 0) {
                this.settings.onComplete.call(this.element);
            }

            // Wait until new files are droped
            this.queuePos = (this.queue.length - 1);

            this.queueRunning = false;

            return false;
        }

        this.queueRunning = true;

        // Start next file
        return this.queue[this.queuePos].upload();
    };

    DmUploader.prototype.restartQueue = function()
    {
        this.queuePos = -1;
        this.queueRunning = false;

        this.processQueue();
    };

    DmUploader.prototype.findById = function(id)
    {
        var r = false;

        for (var i = 0; i < this.queue.length; i++) {
            if (this.queue[i].id === id) {
                r = this.queue[i];
                break;
            }
        }

        return r;
    };

    DmUploader.prototype.cancelAll =  function()
    {
        var queueWasRunning = this.queueRunning;
        this.queueRunning = false;

        // cancel 'em all
        for (var i = 0; i < this.queue.length; i++) {
            this.queue[i].cancel();
        }

        if (queueWasRunning) {
            this.settings.onComplete.call(this.element);
        }
    };

    DmUploader.prototype.startAll = function()
    {
        if (this.settings.queue) {
            // Resume queue
            this.restartQueue();
        } else {
            // or upload them all
            for (var i = 0; i < this.queue.length; i++) {
                this.queue[i].upload();
            }
        }
    };

    // Public API methods
    DmUploader.prototype.methods = {
        start: function(id) {
            if (this.queueRunning){
                // Do not allow to manually upload Files when a queue is running
                return false;
            }

            var file = false;

            if (typeof id !== "undefined") {
                file = this.findById(id);

                if (!file) {
                    // File not found in stack
                    $.error("File not found in jQuery.dmUploader");

                    return false;
                }
            }

            // Trying to Start an upload by ID
            if (file) {
                if (file.status === FileStatus.CANCELLED) {
                    file.status = FileStatus.PENDING;
                }
                return file.upload();
            }

            // With no id provided...

            this.startAll();

            return true;
        },
        cancel: function(id) {
            var file = false;
            if (typeof id !== "undefined") {
                file = this.findById(id);

                if (!file) {
                    // File not found in stack
                    $.error("File not found in jQuery.dmUploader");

                    return false;
                }
            }

            if (file) {
                return file.cancel(true);
            }

            // With no id provided...

            this.cancelAll();

            return true;
        },
        reset: function() {

            this.cancelAll();

            this.queue = [];
            this.queuePos = -1;
            this.activeFiles = 0;

            return true;
        },
        destroy: function() {
            this.cancelAll();

            this.releaseEvents();

            this.element.removeData(pluginName);
        }
    };

    $.fn.dmUploader = function(options) {
        var args = arguments;

        if (typeof options === "string") {
            this.each(function() {
                var plugin = $.data(this, pluginName);

                if (plugin instanceof DmUploader) {
                    if (typeof plugin.methods[options] === "function") {
                        plugin.methods[options].apply(plugin, Array.prototype.slice.call(args, 1));
                    } else {
                        $.error("Method " +  options + " does not exist in jQuery.dmUploader");
                    }
                } else {
                    $.error("Unknown plugin data found by jQuery.dmUploader");
                }
            });
        } else {
            return this.each(function () {
                if (!$.data(this, pluginName)) {
                    $.data(this, pluginName, new DmUploader(this, options));
                }
            });
        }
    };
}));